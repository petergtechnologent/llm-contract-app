from fastapi import APIRouter, Depends, UploadFile, File, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
import openai

from ..database import get_db
from .. import models, schemas
from ..config import OPENAI_API_KEY

router = APIRouter()

@router.get("/contracts", response_model=List[schemas.ContractResponse])
def list_contracts(db: Session = Depends(get_db)):
    """
    GET /api/contracts
    Return all contracts in the database.
    """
    return db.query(models.Contract).all()

@router.post("/contracts", response_model=schemas.ContractResponse)
async def create_contract(
    file: UploadFile = File(...),
    db: Session = Depends(get_db)
):
    """
    POST /api/contracts
    Handle a file upload, store text in `contracts` table.
    """
    contents = await file.read()
    text_str = contents.decode("utf-8", errors="ignore")

    contract = models.Contract(
        file_name=file.filename,
        original_text=text_str,
    )
    db.add(contract)
    db.commit()
    db.refresh(contract)
    return contract

@router.get("/contracts/{contract_id}", response_model=schemas.ContractDetailResponse)
def get_contract_details(contract_id: int, db: Session = Depends(get_db)):
    """
    GET /api/contracts/{contract_id}
    Retrieve a single contract and its revisions.
    """
    contract = db.query(models.Contract).filter(models.Contract.id == contract_id).first()
    if not contract:
        raise HTTPException(status_code=404, detail="Contract not found")
    return contract

@router.post("/contracts/{contract_id}/review", response_model=schemas.ContractRevisionResponse)
def review_contract(
    contract_id: int,
    review_request: schemas.ReviewRequest,  
    db: Session = Depends(get_db)
):
    """
    POST /api/contracts/{contract_id}/review
    Generate a revised contract via OpenAI, store in `contract_revisions`.
    """
    instructions = review_request.instructions or "No additional instructions provided."

    contract = db.query(models.Contract).filter(models.Contract.id == contract_id).first()
    if not contract:
        raise HTTPException(status_code=404, detail="Contract not found")

    if not OPENAI_API_KEY:
        raise HTTPException(status_code=500, detail="OpenAI API key not configured")

    openai.api_key = OPENAI_API_KEY
    # Build a user prompt for a ChatCompletions call
    prompt = f"""
    ---INSTRUCTIONS---
    Please propose a revised version of a contract for greater clarity. 
    Ensure the revised contract meets legal standards.

    Add the following instructions or legal guidelines:
    {instructions}

    ---CONTRACT TEXT---:
    {contract.original_text}

    """
    # Build messages for a ChatCompletion call
    messages = [
        {"role": "system", "content": "You are a helpful legal assistant who specializes in contract editing."},
        {
            "role": "user",
            "content": prompt
        }
    ]
    print("DEBUG print var = ", prompt)
    try:
        print("DEBUG: Passing instructions =", instructions)
        response = openai.ChatCompletion.create(
            model="gpt-4o",  
            messages=messages,
            max_tokens=4096,
            temperature=0.8,
        )
        print("DEBUG: Raw OpenAI response:", response)
        revised_text = response.choices[0].message.content
        print("DEBUG: revised_text = ", revised_text)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    revision = models.ContractRevision(
        contract_id=contract.id,
        revision_text=revised_text,
        revision_notes="Auto-generated by OpenAI"
    )
    db.add(revision)
    db.commit()
    db.refresh(revision)
    return revision

@router.get("/contracts/{contract_id}/download")
def download_contract(
    contract_id: int,
    version: Optional[str] = "original",
    db: Session = Depends(get_db)
):
    """
    GET /api/contracts/{contract_id}/download?version=original|revised
    Return the selected version's text. 
    """
    contract = db.query(models.Contract).filter(models.Contract.id == contract_id).first()
    if not contract:
        raise HTTPException(status_code=404, detail="Contract not found")

    if version == "original":
        content = contract.original_text
        filename = f"{contract.file_name or 'contract'}-original.txt"
    else:
        revision = (
            db.query(models.ContractRevision)
            .filter(models.ContractRevision.contract_id == contract_id)
            .order_by(models.ContractRevision.created_at.desc())
            .first()
        )
        if not revision:
            raise HTTPException(status_code=404, detail="No revisions found for this contract")
        content = revision.revision_text
        filename = f"{contract.file_name or 'contract'}-revised.txt"

    return {
        "file_name": filename,
        "content": content
    }
